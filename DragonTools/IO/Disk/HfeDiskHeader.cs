/*
   Copyright 2011-2020 Rolf Michelsen

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

using System;
using System.IO;


namespace RolfMichelsen.Dragon.DragonTools.IO.Disk
{
    /// <summary>
    /// The file header for a HFE virtual disk file.
    /// </summary>
    public sealed class HfeDiskHeader
    {
        /// <summary>
        /// Magic number used to identify HFE disk images.
        /// </summary>
        private static readonly byte[] HeaderSignature = { 0x48, 0x58, 0x43, 0x50, 0x49, 0x43, 0x46, 0x45 };

        /// <summary>
        /// Size of the encoded disk header as returned by the Encode function.
        /// </summary>
        private readonly int EncodedHeaderSize = 26;


        /// <summary>
        /// The file format version generated by this class.
        /// </summary>
        private readonly int DefaultFileFormatVersion = 0;


        /// <summary>
        /// Default disk bit rate (kbit/s).
        /// </summary>
        private readonly int DefaultDiskBitRate = 250;


        /// <summary>
        /// Default disk rotation speed (rpm).
        /// </summary>
        private readonly int DefaultDiskRotationSpeed = 0;


        public int FileFormatVersion { get; private set; }
        
        public int Tracks { get; private set; }
        
        public int Sides { get; private set; }
        
        /// <summary>
        /// Track encoding.
        /// </summary>
        public TrackEncodingMode TrackEncoding { get; private set; }

        /// <summary>
        /// Track encoding for track 0 side 0.
        /// </summary>
        public TrackEncodingMode TrackEncoding0 { get; private set; }

        /// <summary>
        /// Track encoding for track 0 side 1.
        /// </summary>
        public TrackEncodingMode TrackEncoding1 { get; private set; }

        /// <summary>
        /// Disk bit rate measured in kbit/s.  This value is not used by this class.
        /// </summary>
        public int DiskBitRate { get; private set; }
        
        /// <summary>
        /// Disk rotation speed measured in rpm.  This value is not used by this class.
        /// </summary>
        public int DiskRotationSpeed { get; private set; }
        
        public FloppyInterfaceMode FloppyInterface { get; private set; }

        /// <summary>
        /// Offset of block containing the disk track list.
        /// </summary>
        public int TrackListBlock { get; private set; }

        public bool IsDiskWriteProtected { get; private set; }

        public bool IsSingleStepMode { get; private set; }



        /// <summary>
        /// Create a HFE disk header object by parsing raw HFE disk diskImage data.
        /// </summary>
        /// <param name="diskImage">The first 512 bytes from the HFE disk diskImage.</param>
        public HfeDiskHeader(byte[] diskImage)
        {
            if (diskImage == null) throw new NullReferenceException("diskImage");
            Decode(diskImage);
        }


        /// <summary>
        /// Create a HFE dik header object by reading the encoded HFE header from the stream.
        /// </summary>
        /// <param name="diskImageStream">Stream for reading the HFE disk image.</param>
        public HfeDiskHeader(Stream diskImageStream)
        {
            if (diskImageStream == null) throw new ArgumentNullException("diskImageStream");
            var headerEncoded = new byte[HfeDisk.BlockSize];
            diskImageStream.Seek(0, SeekOrigin.Begin);
            IOUtils.ReadBlock(diskImageStream, headerEncoded, 0, headerEncoded.Length);
            Decode(headerEncoded);
        }


        /// <summary>
        /// Create a HFE disk header object.
        /// </summary>
        /// <param name="sides">Number of disk sides (1 or 2).</param>
        /// <param name="tracks">Number of tracks per head.</param>
        /// <param name="trackListBlock">Block offset of the track list</param>
        public HfeDiskHeader(int sides, int tracks, int trackListBlock)
        {
            FileFormatVersion = DefaultFileFormatVersion;
            Tracks = tracks;
            Sides = sides;
            TrackEncoding = TrackEncodingMode.ISOIBM_MFM;
            TrackEncoding0 = TrackEncodingMode.ISOIBM_MFM;
            TrackEncoding1 = TrackEncodingMode.ISOIBM_MFM;
            DiskBitRate = DefaultDiskBitRate;
            DiskRotationSpeed = DefaultDiskRotationSpeed;
            FloppyInterface = FloppyInterfaceMode.GENERIC_SHUGART_DD;
            IsDiskWriteProtected = false;
            IsSingleStepMode = true;
            TrackListBlock = trackListBlock;
        }



        /// <summary>
        /// Create a HFE disk header object by parsing raw HFE disk diskImage data.
        /// </summary>
        /// <param name="diskImage">The first 512 bytes from the HFE disk diskImage.</param>
        private void Decode(byte[] diskImage)
        {
            if (diskImage.Length < 26) throw new ArgumentException("diskImage too small to contain a complete HFE disk header");

            // Verify header signature
            int offset = 0;
            for (var i = 0; i < HeaderSignature.Length; i++, offset++)
            {
                if (diskImage[offset] != HeaderSignature[i]) throw new ArgumentException("Invalid HFE disk header signature");
            }

            // Parse header fields
            FileFormatVersion = diskImage[offset++];
            Tracks = diskImage[offset++];
            Sides = diskImage[offset++];
            TrackEncoding = (TrackEncodingMode) diskImage[offset++];
            DiskBitRate = diskImage[offset++] | (diskImage[offset++] << 8);
            DiskRotationSpeed = diskImage[offset++] | (diskImage[offset++] << 8);
            FloppyInterface = (FloppyInterfaceMode) diskImage[offset++];
            offset++;
            TrackListBlock = diskImage[offset++] | (diskImage[offset++] << 8);
            IsDiskWriteProtected = (diskImage[offset++] == 0);
            IsSingleStepMode = (diskImage[offset++] != 0);
            TrackEncoding0 = (diskImage[offset] == 0 ? (TrackEncodingMode)(diskImage[offset + 1]) : TrackEncoding);
            offset += 2;
            TrackEncoding1 = (diskImage[offset] == 0 ? (TrackEncodingMode)(diskImage[offset + 1]) : TrackEncoding);

            // Validate header fields
            if (FileFormatVersion != DefaultFileFormatVersion) throw new ArgumentException("Unsupported file format version");
            if (!Enum.IsDefined(typeof(TrackEncodingMode), TrackEncoding)) throw new ArgumentException("Invalid track encoding mode");
            if (!Enum.IsDefined(typeof(TrackEncodingMode), TrackEncoding0)) throw new ArgumentException("Invalid track encoding mode (track 1, side 0)");
            if (!Enum.IsDefined(typeof(TrackEncodingMode), TrackEncoding1)) throw new ArgumentException("Invalid track encoding mode (track 1, side 1)");
            if (!Enum.IsDefined(typeof(FloppyInterfaceMode), FloppyInterface)) throw new ArgumentException("Invalid floppy interface mode");
        }


        /// <summary>
        /// Returns the encoded version of the HFE disk header.
        /// </summary>
        /// <returns>Encoded disk header.</returns>
        public byte[] Encode()
        {
            var encodedHeader = new byte[EncodedHeaderSize];
            var encodedHeaderPos = 0;
            Array.Copy(HeaderSignature, 0, encodedHeader, encodedHeaderPos, HeaderSignature.Length);
            encodedHeaderPos += HeaderSignature.Length;
            encodedHeader[encodedHeaderPos++] = (byte) DefaultFileFormatVersion;
            encodedHeader[encodedHeaderPos++] = (byte) Tracks;
            encodedHeader[encodedHeaderPos++] = (byte) Sides;
            encodedHeader[encodedHeaderPos++] = (byte) TrackEncoding;
            encodedHeader[encodedHeaderPos++] = (byte) (DiskBitRate & 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) ((DiskBitRate >> 8) & 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) (DiskRotationSpeed & 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) ((DiskRotationSpeed >> 8) & 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) FloppyInterface;
            encodedHeader[encodedHeaderPos++] = 1;          // Unused byte, let's use the same value as the HFE disk tools
            encodedHeader[encodedHeaderPos++] = (byte) (TrackListBlock & 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) ((TrackListBlock >> 8) & 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) (IsDiskWriteProtected ? 0 : 0xff);
            encodedHeader[encodedHeaderPos++] = (byte) (IsSingleStepMode ? 0xff : 0);
            encodedHeader[encodedHeaderPos++] = (byte) (TrackEncoding0 == TrackEncoding ? 0xff : 0);
            encodedHeader[encodedHeaderPos++] = (byte) TrackEncoding0;
            encodedHeader[encodedHeaderPos++] = (byte) (TrackEncoding1 == TrackEncoding ? 0xff : 0);
            encodedHeader[encodedHeaderPos] = (byte) TrackEncoding1;
            return encodedHeader;
        }


        public enum TrackEncodingMode
        {
            ISOIBM_MFM = 0x00,
            AMIGA_MFM = 0x01,
            ISOIBM_FM = 0x02,
            EMU_FM = 0x03,
            UNKNOWN = 0xff
        }


        public enum FloppyInterfaceMode
        {
            IBMPC_DD = 0x00,
            IBMPC_HD = 0x01,
            ATARIST_DD = 0x02,
            ATARIST_HD = 0x03,
            AMIGA_DD = 0x04,
            AMIGA_HD = 0x05,
            CPC_DD = 0x06,
            GENERIC_SHUGART_DD = 0x07,
            IBMPC_ED = 0x08,
            MSX2_DD = 0x09,
            C64_DD = 0x0a,
            EMU_SHUGART = 0x0b,
            S950_DD = 0x0c,
            S950_HD = 0x0d,
            DISABLED = 0xfe
        }

    }
}
